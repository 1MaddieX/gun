{
  "name": "theory",
  "version": "0.2.6",
  "author": {
    "name": "Mark Nadal"
  },
  "description": "Abstraction layer for server side and client side JavaScript.",
  "homepage": "http://github.com/amark/theory",
  "engines": [
    "node >= 0.6.6"
  ],
  "main": "theory",
  "readme": "Theory\n======\n\nTheory is an abstraction layer for server side and client side JavaScript.\n\nMotivation\n==========\n\n1.  **Deep existence**. It all started because a program would crash via\n    `if(obj.x.y.z)` rather than `if(obj && obj.x && obj.x.y && obj.x.y.z)`, so I\n    wanted an elegant way to check and access deeply nested objects in a safe\n    yet concise manner.\n\n2.  **Dependency management**. You should not have to declare dependencies in\n    another language (HTML) to import required code or rely on globals. Other\n    tools that solve this foolishly break Node's style in order to make it work\n    asynchronously.\n\n3.  **Universal normalization**. Write once, run everywhere. This dream gets\n    broken when you discover different implementations of JavaScript behave in\n    unique ways, whether browsers or phones and tablets, or IE6 versus server\n    side. I needed a reliable yet tiny library (at **7KB** gzipped) that would\n    normalize everything so any code written would literally work everywhere.\n\nRequire\n=======\n\nAs simple as `npm install theory` on Node and a single `<script\nsrc='./theory.js'></script>` client side. The brilliant thing is that you do not\nhave to declare anything else after that, you can handle the rest within your\nmodule.\n\n\tmodule.exports=require('theory')\n\t('hello', function(a){\n\t\t\n\t\tvar say = \"Hello World!\";\n\t\tconsole.log(say);\n\t\treturn say;\n\t\t\n\t}, ['./needed', './dependency']);\n\nThis is the beautiful fix that works everywhere. You get your own closure which\nexecutes only after all your dependencies (and all of their sub-dependencies)\nhave loaded - then whatever you return from your closure gets exported out!\n\nSay you name this file as 'world.js', all you have to do is run `node world.js`\non the server or put `require('world')` on the client inside the 'theory.js'\nscript tag (or have a normal 'world.js' script tag below theory.js). All\ndependencies are relative to your file, not the HTML page or the parent module!\n\nIf the dependency you require uses some global variable, you can access it from\nthere (such as `jQuery`) as usual. You can access `theory` as a global, but you\nshould not use it globally - theory copies itself into the scope of each module\n(the `a` argument, henceforth used for the rest of this documentation).\n\nAll dependencies that use exports (normal Node modules and theory specific\nmodules) get attached to your module's local scope with their base filename\n(`a.needed` and `a.dependency` in the example above). If you have conflicting\nnames or just want a different name then use an object to declare dependencies\ninstead of an array (`{'./needed': 'foo', './dependency': 'bar'}` become `a.foo`\nand `a.bar`). Theory modules also attach to their own namespace, such as\n`theory.hello` in above.\n\nYou can also specify sub dependencies, such as `{'./jquery':['./jquery-ui',\n'./jquery-ext']}`. Define environment specific dependencies by checking for\n`root.page` or `root.node`. Finally, [imports.js](https://gist.github.com/amark/6291429) \nis an unmaintained version of just the require feature, without anything below.\n\n*Now let's dive into the API.*\n\nBinary\n======\n\n-   **is** `a.bi.is(what)`\n\n    -   determines to see if what is a boolean or not.\n\n    -   Examples\n\n        -   `a.bi.is(false)` → `true`\n\n        -   `a.bi.is(true)` → `true`\n\n        -   `a.bi.is(0)` → `false`\n\n        -   `a.bi.is('yes')` → `false`\n\nNumbers\n=======\n\n-   **is** `a.num.is(what)`\n\n    -   determines to see if what is a number or not.\n\n    -   Examples\n\n        -   `a.num.is(0)` → `true`\n\n        -   `a.num.is(NaN)` → `false`\n\n        -   `a.num.is(1.1)` → `true`\n\n        -   `a.num.is(Infinity)` → `true`\n\n-   **ify** `a.num.ify(what, opt)`\n\n    -   what is the number, text, whatever that needs to be converted into a\n        number.\n\n    -   opt is options parameter.\n\n        -   `[]` indicates you want a list of numbers returned.\n\n    -   Examples\n\n        -   `a.num.ify(\"A37\")` → `37`\n\n        -   `a.num(\"It is -22.7 degrees\").ify()` → `-22.7`\n\n        -   `a.num(\"My values are 33, -2.2, and 6.\").ify([])` → `[33, -2.2, 6]`\n\n-   **random** `a.num.random(what)` or `a.num.r(what)`\n\n    -   if what is a number, it represents how many digits long you want your\n        random number.\n\n    -   if what is a list, it represents the inclusive range you want your\n        random number to be in.\n\n    -   *Note:* Maximum length is 14, what defaults to 6.\n\n    -   Examples\n\n        -   `a.num.random()` → `583587`\n\n        -   `a.num(2).r()` → `64`\n\n        -   `a.num([-10,10]).random()` → `-7`\n\n        -   `a.num.r([1,99])` → `99`\n\nText\n====\n\n-   **is** `a.text.is(what)`\n\n    -   determines to see if what is text or not.\n\n    -   Examples\n\n        -   `a.text.is(\"\")` → `true`\n\n        -   `a.text.is([])` → `false`\n\n        -   `a.text.is(\"Hello World!\")` → `true`\n\n-   **ify** `a.text.ify(what)`\n\n    -   what is the number, text, list, object, whatever you want to turn into\n        text.\n\n    -   *Note:* Essentially just a wrapper for `JSON.stringify()` for now.\n\n    -   Examples\n\n        -   `a.text.ify({a:0,b:'1',c:[0,'1'],d:{e:'f'}})` →\n            `\"{a:0,b:'1',c:[0,'1'],d:{e:'f'}}\"`\n\n-   **random** `a.text.random(what, length)` or `a.text.r(what, length)`\n\n    -   what is a text of allowed characters to be used. Defaults to\n        alpha-numeric characters.\n\n    -   length is how many characters long you want your random text. Defaults\n        to 16.\n\n    -   *Note:* Does not matter what order you call the parameters in.\n\n    -   Examples\n\n        -   `a.text.random()` → `\"uTkphuTCmzQ7Pl3e\"`\n\n        -   `a.text.r(\"AaSsDdFf\",4)` → `\"fDds\"`\n\n        -   `a.text(4).random(\"j$k4\")` → `\"kj$k\"`\n\n        -   `a.text(\"randomize\").r()` → `\"oadomneradnimarz\"`\n\n-   **clip** `a.text(what).clip(split, start, end)`\n\n    -   what is the text to clip.\n\n    -   split is the text or regex to split and rejoin upon.\n\n    -   start is the start position of the slice.\n\n    -   end is the end position of the slice.\n\n    -   Examples\n\n        -   `a.text('A B C D').clip(' ',0,-1)` → `\"A B C\"`\n\n        -   `a.text.clip(\"path/to/awesome.js\",'.',-1)` → `\"js\"`\n\n-   **caps** `a.text.caps(what)`\n\n    -   what is the text you want to capitalize.\n\n    -   Examples\n\n        -   `a.text.caps(\"shout1\")` → `\"SHOUT1\"`\n\n-   **low** `a.text.low(what)`\n\n    -   what is the text you want to make lower case.\n\n    -   Examples\n\n        -   `a.text.low(\"HUSH!\")` → `\"hush!\"`\n\n-   **find** a collection of Regular Expressions.\n\n    -   *Note:* No guarantee of these working or being available in future\n        versions.\n\nLists\n=====\n\n-   **is** `a.list.is(what)`\n\n    -   determines to see if what is a list or not.\n\n    -   Examples\n\n        -   `a.list.is([])` → `true`\n\n        -   `a.list.is(\"list\")` → `false`\n\n        -   `a.list.is([0,false])` → `true`\n\n-   **ify** `a.list.ify(what, opt)`\n\n    -   what is the text or object that you want to convert into a list.\n\n    -   opt is the options parameter.\n\n        -   split: what to divide upon for text, whitespace auto handled. `','`\n            is default.\n\n        -   wedge: what token to use as the divider between an object’s key and\n            value. `':'` default.\n\n    -   Examples\n\n        -   `a.list.ify(\"Bob, Joe,Isaac , Fred\")` →\n            `[\"Bob\",\"Joe\",\"Isaac\",\"Fred\"]`\n\n        -   `a.list({a:1,b:'c',d:[1,2,3]}).ify()` → `['a:1','b:c','d:0,1,2']`\n\n        -   `a.list({session:'AK41795'}).ify({wedge:'='})` →\n            `['session=AK41795']`\n\n        -   `a.list.ify(\"1,2,3 ; 4,5,6\",{split:';'})` → `[\"1,2,3\", \"4,5,6\"]`\n\n-   **at** `a.list.at(what, index, opt)`\n\n    -   what is the list you want to access.\n\n    -   index is the where in the list you want to retrieve the value.\n\n    -   opt is the options parameter.\n\n        -   ebb: causes an over reaching index to cascade till it finds the\n            closest item.\n\n    -   Examples\n\n        -   `a.list.at([5,6,7,8,9],-2)` → `8`\n\n        -   `a.list([5,6,7,8,9]).at(2)` → `6`\n\n        -   `a.list.at([2,3,4],9,{ebb:true})` → `4`\n\n        -   `a.list([0,1,2]).at(-9,{ebb:true})` → `0`\n\n        -   `a.list.at([5,6,7],-2,{ebb:true})` → `6`\n\n-   **fuse** `a.list.fuse(what, ...)`\n\n    -   what is the list that other lists will fuse into.\n\n    -   … any number of extra list parameters.\n\n    -   Examples\n\n        -   `a.list.fuse([2,3],[4,5],[6,7])` → `[2,3,4,5,6,7]`\n\n        -   `a.list([2,3]).fuse([3,4],[4,5])` → `[2,3,3,4,4,5]`\n\n-   **less** `a.list.less(what, ...)`\n\n    -   what is the list you want to subtract items from.\n\n    -   … the items you want to remove from the list,\n\n    -   Examples\n\n        -   `a.list.less([0,1,false,'a',false],false)` → `[0,1,'a']`\n\n        -   `a.list([2,2,7,['a'],1,9,0,31]).less(0,['a'],2)` → `[7, 1, 9, 31]`\n\n    -   *Note:* An option to pass a list of items to be removed exists by\n        indicating you only want `2` parameters, such that\n        `a.list(2).less([0,1,2,2,3,4],[0,2])` → `[1,3,4]`.\n\n-   **find** `a.list.find(list, what)`\n\n    -   list is the list you want to search.\n\n    -   what is the item you are looking for.\n\n    -   Examples\n\n        -   `a.list([4,5]).find(9)` → `0`\n\n        -   `a.list([4,5]).find(5)` → `2`\n\n        -   `a.list.find([4,5],4)` → `1`\n\n-   **each** `a.list.each(list, function, this)`\n\n    -   list is the list you want to iterate through each of its items.\n\n    -   function is your callback which gets executed sequentially, on each\n        item.\n\n        -   the first parameter is the current item’s value.\n\n        -   the second parameter is the current index of that value in the list.\n\n        -   the third parameter is a map function, which when called pushes its\n            argument into a list that is returned by default by `each`.\n\n        -   `return;` or `return undefined;` immediately proceeds to the next\n            item.\n\n        -   return anything else and the loop breaks, then `each` returns the\n            value you returned instead.\n\n    -   this is an optional argument that will become the `this` inside the\n        function.\n\n    -   Examples\n\n        -   `a.list([1,2,3]).each(function(val, i, map){ map(val + i) })` → `[2,\n            4, 6]`\n\n        -   `a.list([1,2,3]).each(function(){ return \"Hello World!\"; })` →\n            `\"Hello World!\"`\n\n        -   `a.list([1,2,3]).each(function(val, i, map){ if(val == 2){ return }\n            map(val); })` → `[1,3]`\n\n        -   `a.list([1,2,3]).each(function(val, i, map){ map(val); if(val == 2){\n            return val } })` → `2`\n\n        -   `a.list([{name:'joe',age:27},{name:'bob',age:42}]).each(function(val,\n            i, map){ map(val.name) })` → `['joe','bob']`\n\n        -   `a.list(['a','b','c']).each(function(){ return this })` → `//\n            current context`\n\n        -   `a.list(['a','b','c']).each(function(){ return this }, {z:1})` →\n            `{z:1}`\n\nNotes\n-----\n\nTheory uses lists and index notation, not arrays and offset notation. Offset\nnotation is the common practice of describing the position of an element in an\narray by its corresponding location in the physically allocated space of\ncontiguous memory, which logically starts at a zeroth initial. This is otherwise\nshortened to \"0 based index arrays\", despite the misnomer of it actually being\nan offset. The author of this library has chosen index notation instead because\nit offers the following advantages:\n\n1.  Naturally, the first element in a list cardinally corresponds to `1`.\n    Contrarily, even official documentation of JavaScript has explicit\n    disclaimers that the \"first element of an array is actually at index 0\" -\n    this is easily forgotten, especially by novices, and can lead to errors.\n\n2.  Mathematically, a closed interval is properly represented in code as `for(i\n    = 1; i <= items.length; i++)`, because it includes its endpoints. Offset\n    notation instead is technically a left-closed right-open interval set,\n    represented in code as `for(i = 0; i < items.length; i++)`. This matters\n    because code deals with integer intervals, because all elements have a fixed\n    size - you can not access a fractional part of an element. Integer intervals\n    are closed intervals, thus conclusively proving this importance.\n\n3.  Mathematically, matrix notation also starts with `1`.\n\n4.  The last element in a list cardinally corresponds to the length of the list,\n    thus allowing easy access with `items.length` rather than having frustrating\n    `(items.length - 1)` arithmetic everywhere in your code.\n\n5.  Negative indices are symmetric with positive indices. Such that `-1` and `1`\n    respectively refer to the last and first element, and in the case where\n    there is only one item in the list, it matches the same element. This\n    convenience allows for simple left and right access that offset notation\n    does not provide.\n\n6.  Non existence of an element can be represented by `0`, which would\n    conveniently code elegantly as `if( !items.indexOf('z') ) return;`. Rather,\n    one must decide upon whether `if( items.indexOf('z') == -1 ) return;` is\n    philosophically more meaningful than `if( items.indexOf('z') < 0 ) return;`\n    with offset notation despite ignoring the asymmetry of the equation.\n\nStill irrational? Then switch it back via `a.list.index = 0` in your closure.\n\nObjects\n=======\n\n-   **is** `a.obj.is(what)`\n\n    -   determines to see if what is an object or not.\n\n    -   Examples\n\n        -   `a.obj.is({})` → `true`\n\n        -   `a.obj.is(function(){})` → `false`\n\n        -   `a.obj.is([])` → `false`\n\n-   **ify** `a.obj.ify(what)`\n\n    -   what is the text-ified object you want to parse into an object.\n\n    -   *Note:* Essentially just a wrapper for `JSON.parse()` for now.\n\n    -   Examples\n\n        -   `a.obj.ify('[0,1]')` → `[0,1]`\n\n        -   `a.obj('{\"a\":false,\"b\":1,\"c\":\"d\",\"e\":[0,1],\"f\":{\"g\":\"h\"}}').ify()` →\n            `{\"a\":false,\"b\":1,\"c\":\"d\",\"e\":[0,1],\"f\":{\"g\":\"h\"}}`\n\n-   **has** `a.obj.has(what, key)`\n\n    -   what is the object you want to test the existence of a key or property\n        on.\n\n    -   key is the property you want to see if exists in what.\n\n    -   Examples\n\n        -   `a.obj.has({yay:false},'yay')` → `true`\n\n        -   `a.obj({yay:false}).has('toString')` → `false`\n\n-   **empty** `a.obj.empty(what)`\n\n    -   what is the object you want to test to see if it is empty.\n\n    -   Examples\n\n        -   `a.obj.empty({})` → `true`\n\n        -   `a.obj({a:0}).empty()` → `false`\n\n-   **copy** `a.obj.copy(what)`\n\n    -   what is the object or list that you want to make a deep duplicate of.\n\n    -   Examples\n\n        -   `a.obj.copy({a:[0,1],b:function(){ return 1 }})` →\n            `{a:[0,1],b:function(){ return 1 }}`\n\n        -   `a.obj([{a:1},{b:2}]).copy()` → `[{a:1},{b:2}]`\n\n-   **union** `a.obj.union(what, ...)` or `a.obj(what).u(...)`\n\n    -   what is the object you want to merge into, or a list of objects to\n        merge.\n\n    -   ... are more objects to be merged.\n\n    -   *Note:* You can provide a list of objects instead, which will be merged.\n\n    -   Examples\n\n        -   `a.obj.union({a:'b',c:'d'},{c:1,z:2})` → `{a:'b',c:'d',z:2}`\n\n        -   `a.obj([{a:1},{b:2}]).union()` → `{a:1,b:2}`\n\n        -   `a.obj({a:'b',c:'d'}).u({c:1,z:2},{x:3,y:4})` →\n            `{a:'b',c:'d',x:3,y:4,z:2}`\n\n        -   `a.obj.u([{a:1,b:2},{b:3,x:4},{y:5}])` → `{a:1,b:2,x:4,y:5}`\n\n-   **get** `a.obj.get(what, where)` or `a(what, where)`\n\n    -   what is the object you want to get something from.\n\n    -   where is a dot separated text of keys to the thing you want to get.\n\n        -   numbers indicate a list index, if not specified it will scan through\n            the list.\n\n        -   \"-\\>\" postfix indicates you will be calling a function, but if not\n            found it will return a fail safe function.\n\n    -   *Note:* Warning, fails if the property name itself contains a '.' dot in\n        it.\n\n    -   Examples\n\n        -   `a.obj.get({a:4,b:6,c:8},'b')` → `6`\n\n        -   `a.obj({a:4,b:6,c:8}).get('z')` → `undefined`\n\n        -   `a.obj({a:{z:{b:{y:{c:{x:'deep'}}}}}}).get('a.z.b.y.c.x')` →\n            `'deep'`\n\n        -   `a.obj({a:[1,[2,{b:{c:'scan'}},3],4]}).get('a.b.c')` → `'scan'`\n\n        -   `a.obj({a:[1,{b:'index'},3]}).get('a.2.b')` → `'index'`\n\n        -   `a.obj({a:[1,{b:'index'},3]}).get('a.-2.b')` → `'index'`\n\n        -   `a.obj({a:{b:function(c){return c*c}}}).get('a.b->')(2)` → `4`\n\n        -   `a.obj({a:1}).get('a.b->')(2)` → `undefined // fail safe`\n\n        -   `a.obj({a:1}).get('a.b')(2)` → `TypeError: undefined is not a\n            function`\n\n-   **each** `a.obj.each(object, function, this)`\n\n    -   object is the object you want to iterate through each of its key/value\n        pairs.\n\n    -   function is your callback which gets executed on each pair.\n\n        -   the first parameter is the current value.\n\n        -   the second parameter is the key of the value in the object.\n\n        -   the third parameter is a map function, which when called adds a\n            key/value pair to the object that is returned by default by `each`.\n\n        -   `return;` or `return undefined;` immediately proceeds to the next\n            pair.\n\n        -   return anything else and the loop breaks, then `each` returns the\n            value you returned instead.\n\n    -   this is an optional argument that will become the `this` inside the\n        function.\n\n    -   Examples\n\n        -   `a.obj({a:'z',b:'y'}).each(function(val, key, map){ map(val,key) })`\n            → `{y:'b',z:'a'}`\n\n        -   `a.obj({a:'z',b:'y'}).each(function(){ return \"Hello World!\"; })` →\n            `\"Hello World!\"`\n\n        -   `a.obj({a:1,b:2,c:3}).each(function(val, key, map){ if(val == 2){\n            return } map(key,val); })` → `{a:1,c:3}`\n\n        -   `a.obj({a:1,b:2,c:3}).each(function(val, key, map){ map(key,val);\n            if(val == 2){ return val } })` → `2`\n\n        -   `a.obj({z:4}).each(function(){ return this })` → `// current\n            context`\n\n        -   `a.obj({z:4}).each(function(){ return this }, [1,2])` → `[1,2]`\n\nFunctions\n=========\n\n-   **is** `a.fns.is(what)`\n\n    -   determines to see if what is a function or not.\n\n    -   Examples\n\n        -   `a.fns.is(function(){})` → `true`\n\n        -   `a.fns.is({})` → `false`\n\n-   **pass** `a.fns.pass(function, this)`\n\n    -   function is the function that you want this bound to.\n\n    -   this will become the `this` inside the function.\n\n    -   *Note:* The original function is returned for you to then immediately\n        call.\n\n    -   Examples\n\n        -   `a.fns.pass(function(z){ return this.b + z  },{b:1})(2)` → `3`\n\n        -   `a.fns(function(z){ return this.b + z }).pass({b:2})(3)` → `5`\n\n-   **sort** `a.fns.sort(what)`\n\n    -   what is the arguments object of the function you want sorted.\n\n    -   *Note:* An object containing the first letter of each type is returned.\n        The value of these keys is a list with the corresponding arguments of\n        that type, in the same order as they appeared in the original function\n        call.\n\n    -   *Note:* If something goes wrong, an error type is included, with a text\n        value explaining why.\n\n    -   Examples\n\n        -   `(function(){ return a.fns.sort(arguments) })(\"a\",0,\"b\",1,{z:2})` →\n            `{b:[],n:[0,1],t:['a','b'],l:[],o:[{z:2}],f:[]}`\n\n        -   `a.fns.sort()` → `{e:\"Empty\"}`\n\n-   **flow** `a.fns.flow(what, function)`\n\n    -   what is a sequential list of functions to asynchronously iterate\n        through.\n\n        -   the last parameter of each function is the next function in the\n            list.\n\n        -   at any point, the flow can be canceled by calling `.end()` on the\n            last parameter.\n\n    -   function is the callback to be executed at the end of the operations.\n\n    -   Examples\n\n        -   `a.fns.flow([function(next){ next(6) },function(six, next){ next(six\n            / 3) }],function(two){ alert(two) })`\n\n        -   `a.fns.flow([function(next){ next.end(2) },function(){ /* skipped */\n            }],function(two){ alert(two) })`\n\nEvents\n======\n\n-   **event** `a.on(what).event(function)`\n\n    -   what is a string name of the event you want to listen on.\n\n    -   function is the callback function that will be called when the event is\n        emitted.\n\n        -   the `this` object of the callback is the listener object.\n\n    -   returns the listener, which you can call `.off()` on to stop receiving\n        events.\n\n    -   Examples\n\n        -   `a.on('alarm').event(function(task){ alert('Remember to ' + task);\n            this.off(); })`\n\n-   **emit** `a.on(what).emit(data, ...)`\n\n    -   what is a string name of the event you want to emit on.\n\n    -   data and ... are your parameters to emit to the receivers.\n\n    -   Examples\n\n        -   `a.on('alarm').emit('exercise!')`\n\nTime\n====\n\n-   **is** `a.time.is()`\n\n    -   timestamp wrapper for `new Date().getTime()`, but if a parameter is\n        provided it will test if it is an instance of `Date`.\n\n    -   Examples\n\n        -   `a.time.is()` → `1357457565462`\n\n        -   `a.time(new Date()).is()` → `true`\n\n-   **now** `a.time.now()`\n\n    -   hyper precise timestamp, up to four decimals longer than the above.\n\n    -   Examples\n\n        -   `a.time.now()` → `1357457866774.292`\n\n-   **loop** `a.time.loop(function, interval)`\n\n    -   repeatedly calls function every interval millisecond, wrapper for\n        `setInterval`.\n\n    -   *Note:* Does not matter what order you call the parameters in.\n\n    -   Examples\n\n        -   `a.time.loop(function(){ alert('loop') },1000)` → `// returns ID for\n            clearing`\n\n-   **wait** `a.time.wait(function, delay)`\n\n    -   calls function after waiting millisecond delay, wrapper for\n        `setTimeout`.\n\n    -   *Note:* Does not matter what order you call the parameters in.\n\n    -   Examples\n\n        -   `a.time.wait(1000,function(){ alert('wait') })` → `// returns ID for\n            clearing`\n\n-   **stop** `a.time.stop(ID)`\n\n    -   stops the wait or loop associated with the ID from further being\n        executed.\n\n    -   Examples\n\n        -   `a.time.stop(1111)` → `true`\n\nTests\n=====\n\n-   **is** `a.test.is(what, thing)`\n\n    -   what is what you want to compare equivalency against thing.\n\n    -   thing is the thing you want to compare equivalency to what.\n\n    -   Examples\n\n        -   `a.test.is({a:1,b:'c',d:{f:function(){return\n            false}}},{a:1,b:'c',d:{f:function(){return false}}})` → `true`\n\n        -   `a.test(NaN).is(NaN)` → `true`\n\n        -   `a.test.is(function(){return true},function(){ return true; })` →\n            `false`\n\n        -   `a.test(undefined).is(null)` → `false`\n\n-   **test** `a.test(function)()`\n\n    -   function is the function that might break, and you want to test.\n\n    -   *Note:* all this does is wrap it in a `try{}catch(){}` block.\n\n    -   Examples\n\n        -   `a.test(function(){ explode_with_spam })()` → `// error object`\n\n        -   `a.test(function(){ return 'ok'; })()` → `'ok'`\n\nRun them! Using mocha, just `mocha` with Node or `./test/mocha.html` in any\nbrowser.  \n  \nCrafted with love by Mark Nadal, whom is not responsible for any liabilities\nfrom the use of this code.\n",
  "readmeFilename": "README.md",
  "_id": "theory@0.2.6",
  "_from": "theory@~>0.2.6"
}
